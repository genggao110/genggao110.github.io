---
layout:      post
title:       "Operation System"
subtitle:    " \"System deadlock\""
date:        2019-03-29 10:45:26
author:      "Ming"
header-img:  "img/post-bg-stars.jpg"
tags:
    - Operation System
    - DeadLock
---

> "Few things are impossible in themselves; and it is often for want of will, rather than of means, that man fails to succeed."

### 操作系统之死锁及死锁的处理

> 操作系统中死锁是指多个进程在运行过程中由于争夺资源而造成的一种僵局。具体而言，是指在多进程环境中，当一个进程请求资源时，如果该资源不能立即获得，那么进程就会进入等待状态。**如果一个处于等待状态的进程P(i)，由于所等待的资源被另一个处于等待状态的进程P(j)(i != j)所持有，而P(j)所请求的资源又被P(i)持有，这样它们所请求的资源都不会获得，两个进程一直处于等待状态，从而形成死锁。**

#### 死锁产生的原因

##### 1.系统资源的竞争

通常系统中拥有的不可剥夺资源，其数量不足以满足多个进程运行的需要，使得进程在运行过程中，会因争夺资源而陷入僵局，如磁带机、打印机等。只有对不可剥夺资源的竞争才可能产生死锁，对可剥夺资源的竞争是不会引起死锁的。

##### 2.进程推进顺序非法

进程在运行过程中，请求和释放资源的顺序不当，也同样会导致死锁。例如，并发进程P1、P2分别保持了资源R1、R2,而进程P1申请资源R2,进程P2申请资源R1时，两者都会因为所需资源被占用而阻塞。

信号量使用不当也会造成死锁。进程间彼此相互等待对方发来的消息，结果也会使得这些进程间无法继续向前推进。例如，进程A等待进程B发的消息，进程B又在等到进程A发的消息，可以看出进程A和进程B不是因为竞争同一资源，而是在等待对方的资源导致死锁。

##### 3.死锁产生的必要条件

产生死锁必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生：

- 互斥条件：进程要求对所分配的资源(如打印机)进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。
- 不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放(只能是主动释放)
- 请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程阻塞，但对自己已获得的资源保持不放。
- 循环等待条件： 存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求。即存在一个处于等待进程集合{P1,P2,...,Pn},其中Pi等待的资源被P(i+1)占有(i = 0,1,...,n-1)，Pn等待的资源被P0占有。

#### 死锁的解决方法

