---
layout:     post
title:      "JVM"
subtitle:   " \"java 虚拟机\""
date:       2019-08-30 17:53:25
author:     "ming"
catalog: true
header-img: "img/post-bg-house.jpg"
tags:
    - Java
    - JVM
---

> "Some things are not to see to insist, but insisted the will sees hope."

### 1.Java内存区域

对于Java程序员来说，在虚拟机自动内存管理的机制下，不需要像C/C++程序开发这样为一个new操作去写对应的delete/free操作，不容易出现内存泄漏和内存溢出问题。正是因为Java程序员把内存控制权利交给Java虚拟机。一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个艰巨的任务。

#### 1.1 运行时数据区域

Java虚拟机在执行Java程序的过程中会把它管理的内存划分成若干个不同的数据区域。(给出jdk 1.6版本的运行时数据区域图)

![javaMemory.png](https://i.loli.net/2019/08/30/FaVyWKs86owOdqp.png)

这些组成部分一些是线程私有的，其他则是线程共享的。我们由上图可以看出：

线程私有的主要包括：
- 程序计数器
- 虚拟机栈
- 本地方法栈

而线程共享的主要包含：
- 堆
- 方法区
- 直接内存

下面我们来详细地介绍以上提到的各个部分。

##### 1.程序计数器

程序计数器(Program Counter Register)是一块较小的内存空间，它可以看成是当前线程所执行的字节码的行号解释器。**在虚拟机的概念模型里，字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。**

另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。我们称这类内存区域为“线程私有”的内存。

从上面的介绍我们可以知道程序计数器主要有两个作用：
- 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
- 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪里。

> 注意：程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。

##### 2.Java虚拟机栈

与程序计数器一样，Java虚拟机栈(Java Virtual Machine Stack)也是线程私有的，它的生命周期和线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。

**Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。**(实际上，Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。)

`局部变量表`主要存放了编译器可知的各种数据类型(boolean,byte,char,short,int,float,long,double)、对象引用(reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置)和returnAddress类型(指向了一条字节码指令的地址).

Java虚拟机栈会出现两种异常：**StackOverFlowError**和**OutOfMemoryError**.
- StackOverFlowError:若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。
- OutOfMemoryError： 若Java虚拟机栈的内存大小允许动态扩展，只不过当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。

Java虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。

##### 3.本地方法栈

本地方法栈(Native Method Stack)和虚拟机栈所发挥的作用是非常相似的，它们之间的区别在于：**虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的Native方法服务。**在HotSpot虚拟机中和Java虚拟机栈合二为一。

本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。

##### 4.堆

Java堆(Java Heap)是Java虚拟机所管理的内存中最大的一块，是被所有线程共享的一块内存区域。其在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。

Java堆是垃圾回收器管理的主要区域，因此也被称为GC堆(Garbage Collected Heap)。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代：再细致一点有：Eden空间、From Survivor、To Survivor空间等。`进一步划分的目的是更好地回收内存，或者更快地分配内存。`

![java_heap](https://i.loli.net/2019/08/31/RUMx3IYivy8h2Dt.png)

**Attention**:在 JDK1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域（永久代使用的是JVM的堆内存空间，而元空间使用的是物理内存，直接受到本机的物理内存限制）。

##### 5.方法区

方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap(非堆)，目的应该是与Java堆区分开来。

HotSpot虚拟机中方法区也常被称为“永久代”，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存了。但是这并不是一个好主意，因为这样更容易遇到内存溢出问题。

相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。在 JDK1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域，为此下面我们了解一下永久代与元空间的概念。

1. PermGen(永久代)

绝大部分 Java 程序员应该都见过 "java.lang.OutOfMemoryError: PermGen space "这个异常。这里的 “PermGen space”其实指的就是方法区。不过方法区和“PermGen space”又有着本质的区别。前者是 JVM 的规范，而后者则是 JVM 规范的一种实现，并且只有 HotSpot 才有 “PermGen space”，而对于其他类型的虚拟机，如 JRockit（Oracle）、J9（IBM） 并没有“PermGen space”。由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出。最典型的场景就是，在 jsp 页面比较多的情况，容易出现永久代内存溢出。我们现在通过动态生成类来模拟 “PermGen space”的内存溢出：

```java
public class PermGenOonMock {

    public static void main(String[] args) {
        URL url = null;
        List<ClassLoader> classLoaderList = new ArrayList<>();
        try{
            url = new File("/tmp").toURI().toURL();
            URL[] urls = {url};
            while (true){
                ClassLoader classLoader = new URLClassLoader(urls);
                classLoaderList.add(classLoader);
                classLoader.loadClass("com.paddx.test.memory.Test");
            }
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
```

运行结果如下：

![永久代](https://i.loli.net/2019/08/31/i4Fcm5yAbkvfBKI.jpg)

本例中使用的 JDK 版本是 1.7，指定的 PermGen 区的大小为 8M。通过每次生成不同URLClassLoader对象来加载Test类，从而生成不同的类对象，这样就能看到我们熟悉的 "java.lang.OutOfMemoryError: PermGen space " 异常了。这里之所以采用 JDK 1.7，是因为在 JDK 1.8 中， HotSpot 已经没有 “PermGen space”这个区间了，取而代之是一个叫做 Metaspace（元空间） 的东西。下面我们就来看看 Metaspace 与 PermGen space 的区别。

2. Metaspace(元空间)

其实，移除永久代的工作从JDK1.7就开始了。JDK1.7中，存储在永久代的部分数据就已经转移到了Java Heap或者是 Native Heap。但永久代仍存在于JDK1.7中，并没完全移除，譬如符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了java heap；类的静态变量(class statics)转移到了java heap。我们可以通过一段程序来比较 JDK 1.6 与 JDK 1.7及 JDK 1.8 的区别，以字符串常量为例：

```java
public class StringOomMock {

    static String base = "string";
    public static void main(String[] args) {
        List<String> list = new ArrayList<String>();
        for (int i=0;i< Integer.MAX_VALUE;i++){
            String str = base + base;
            base = str;
            list.add(str.intern());
        }
    }
}
```
这段程序以2的指数级不断的生成新的字符串，这样可以比较快速的消耗内存。我们通过 JDK 1.6、JDK 1.7 和 JDK 1.8 分别运行：

JDK 1.6的运行结果：

![JDK 1.6](https://i.loli.net/2019/08/31/UhJ8ipobydcwltk.jpg)

JDK 1.7的运行结果：

![JDK 1.7](https://i.loli.net/2019/08/31/lQfM7uDzPrabjSi.jpg)

JDK 1.8的运行结果：

![JDK 1.8](https://i.loli.net/2019/08/31/2hIrx3qWsFcAVRi.jpg)

从上述结果可以看出，JDK 1.6下，会出现“PermGen Space”的内存溢出，而在 JDK 1.7和 JDK 1.8 中，会出现堆内存溢出，并且 JDK 1.8中 PermSize 和 MaxPermGen 已经无效。因此，可以大致验证 JDK 1.7 和 1.8 将字符串常量由永久代转移到堆中，并且 JDK 1.8 中已经不存在永久代的结论。现在我们看看元空间到底是一个什么东西？

元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：
- XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。
- XX:MaxMetaspaceSize，最大空间，默认是没有限制的。

除了上面两个指定大小的选项之外，还有两个与GC相关的属性：
- XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集
- XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集

现在我们在 JDK 8下重新运行一下之前在上一小节的代码，不过这次不再指定 PermSize 和 MaxPermSize。而是指定 MetaSpaceSize 和 MaxMetaSpaceSize的大小。输出结果如下：

![元空间溢出](https://i.loli.net/2019/08/31/aAdTuwC43pgsJYR.jpg)

从输出结果，我们可以看出，这次不再出现永久代溢出，而是出现了元空间的溢出。

##### 6.运行时常量池

运行时常量池(Runtime Constant Pool)是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息(其用于存放编译期间生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放)。运行时常量池因为是方法区的一部分，所以它也受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。

**JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。**

![字面量与符号引用](https://i.loli.net/2019/09/02/ZztmBX41WfKrhS9.png)

##### 7.直接内存

直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致OutofMemoryError异常出现。

在JDK 1.4中新加入的NIO(New Input/Output)类，引入了一种基于通道与缓存区的I/O方式，它可以直接使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。

本机直接内存的分配不会收到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。

#### 1.2 HotSpot虚拟机对象

通过上面的介绍我们大致了解了虚拟机的内存分布概况，下面我们来深入探讨一下HotSpot虚拟机在Java堆中的对象分配、布局和访问的全过程。

##### 1. 对象的创建

给出Java对象的创建过程如下图所示：

![Java创建对象的过程.png](https://i.loli.net/2019/09/02/dBC2oLa84Ie9NhQ.png)

**Step1:类加载检查**

虚拟机遇到一条new指令的时候，首先会去检查这个指令的参数是否能够在常量池中定位到这个类的符号引用，并且检查这个符号引用所代表的的类是否已经被加载、解析和初始化过。如果没有，那必须执行相应的类加载过程。

**step2:分配内存**

在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。其分配方式有“指针碰撞”和“空闲列表”两种，选择哪一种分配方式是由Java堆是否规整所决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。

内存分配的两种方式：(Java 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的)

1. 指针碰撞:
    - 使用场合：堆内存规整(即没有内存碎片)的情况下
    - 原理：用过的内存全部整合到一边，没有用过的在另一边，中间放着一个指针作为分界点的指示器，只需要向着没有用过的内存方向将该指针移动对象内存大小位置即可。
    - GC收集器：Serial、ParNew
2. 空闲列表：
    - 使用场合：堆内存不规整的情况下
    - 原理：虚拟机会维护一个列表，该列表中记录了哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录
    - GC收集器：CMS

除了如何划分可用空间外，还需要考虑是线程安全的问题，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的(因为可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针分配内存的情况)，通常来说，虚拟机采用了两种方式来保证线程安全：

- **CAS + 失败重试**：CAS是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。
- **TLAB(本地线程分配缓冲)**:把内存分配的动作按照线程划分在不同的空间之中进行，即为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配。

**step3:初始化零值**

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头)，这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值。

**step4：设置对象头**

初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象头中。另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁，对象头会有不同的设置方式。

**step5:执行init方法**

在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从java程序的角度来看，对象创建才刚开始，<init>方法还没有执行，所有的字段都还为零。所以一般来说，执行new指令之后会接着执行<init>方法，把对象按照程序员的意愿进行初始化，这样一个真正的对象才算完全产生出来。

##### 2.对象的内存布局

在Hotspot虚拟机中，对象在内存中的布局可以分为3块区域：**对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。**

Hotspot虚拟机的对象头主要包括两部分信息，第一部分用于存储对象自身的运行时数据(例如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向ID、偏向时间戳等等等等，官方称它为Mark Word)，另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

实例数据部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。

第三部分对齐填充不是必然存在的，也没什么特别的含义，`仅仅起占位作用`。因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。

##### 3.对象的访问定位

建立对象的目的就是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的实现方式有**使用句柄**和**直接指针**两种：

1. 句柄：如果使用句柄访问的话，那么Java堆中将会划分出来一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据域类型数据各自的具体地址信息。

![对象的访问定位-使用句柄.png](https://i.loli.net/2019/09/03/iCjNW3rPtIMne1F.png)

2. 直接指针：如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象的地址。

![对象的访问定位-直接指针.png](https://i.loli.net/2019/09/03/38ILmNvdkpnWCr1.png)

这两种对象访问方式各有优势。而使用句柄来访问的最大好处是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。

### 2.Java垃圾回收

