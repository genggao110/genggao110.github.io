---
layout:     post
title:      "RPC基础知识总结"
subtitle:   " \"RPC总结\""
date:       2019-10-29 22:16:07
author:     "ming"
catalog: true
header-img: "img/post-bg-happiness.jpg"
tags:
    - RPC
    - Dubbo框架
---

> "To choose time is to save time."

## 1. 为什么需要RPC?

随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。

1. 单一应用架构

当网站流量很小的时候，只需要一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删查改工作量的数据访问框架(ORM)是关键。

2. 垂直应用架构

当访问量逐渐增大，单一应用增加机器带来的速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的 Web框架(MVC) 是关键。

3. 分布式服务架构

当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。

此时，用于提高业务复用及整合的分布式服务框架(RPC)，提供统一的服务是关键。例如：各个团队的服务提供方就不要各自实现一套序列化、反序列化、网络框架、连接池、收发线程、超时处理、状态机等“业务之外”的重复技术劳动，造成整体的低效。

4. 流动计算架构

当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需要增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。

5. 另外一个原因

就是因为在几个进程内(应用分布在不同的机器上)，无法共用内存空间，或者在一台机器内通过本地调用无法完成相关的需求，比如不同的系统之间的通讯，甚至不同组织之间的通讯。此外由于机器的横向扩展，需要在多台机器组成的集群上部署应用等等。

所以，统一RPC框架来解决提供统一的服务。

## 2. 什么是RPC?

RPC(Remote Procedure Call Protocol)远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。简而言之，RPC使得程序能够像访问本地系统资源一样，其访问远端系统资源。比较关键的一些方面包括：通讯协议、序列化、资源(接口)描述、服务框架、性能、语言支持等。

![RPC简单框架](https://ws1.sinaimg.cn/large/005CDUpdgy1g8fel1d8pfj30bm05qglm.jpg)

简单的说，RPC就是从一台机器(客户端)上通过参数传递的方式去调用另外一台机器(服务器)上的一个函数或方法(可以统称为服务)并得到返回的结果。

## 3. RPC架构组件

一个基本的RPC框架里面应该至少包含以下4个组件：
- 客户端(Client): 服务调用方(服务消费者)
- 客户端存根(Client Stub): 存放服务器端地址信息，将客户端的请求参数数据信息打包成网络信息，再通过网络传输发送给服务器端。
- 服务器端存根(Server Stub): 接收客户端发送过来的请求信息并进行解包，然后再调用本地服务进行处理。
- 服务端(Server): 服务的真正提供者。

![RPC调用过程](https://ws1.sinaimg.cn/large/005CDUpdgy1g8fete67wnj30fa0b4dfx.jpg)

具体的调用过程如下：
1. 服务消费者(client客户端)通过调用本地服务的方式调用需要消费的服务；
2. 客户端存根(client stub)接收到调用请求后负责将方法、入参等信息序列化(组装)成能够进行网络传输的消息体；
3. 客户端存根(client stub)找到远程的服务地址，并且将消息通过网络发送给客户端；
4. 服务端存根(server stub)收到消息进行解码(反序列化操作)
5. 服务端存根(server stub)根据解码结果调用本地的服务进行相关处理；
6. 本地服务执行具体的业务逻辑并将处理结果返回给服务端存根(server stub);
7. 服务端存根(server stub)将返回结果重新打包成消息(序列化)并通过网络发送至消费方；
8. 客户端存根（client stub）接收到消息，并进行解码（反序列化）；
9. 服务消费方得到最终结果。

而RPC框架的实现目标则是将上面的第2-8步完好地封装起来，也就是把调用、编码/解码的过程给封装起来，让用户感觉上像调用本地服务一样的调用远程服务。

## 4. RPC和SOA、SOAP、REST的区别

**1. REST**

可以看成是HTTP协议的一种直接应用，默认基于JSON作为传输格式,使用简单,学习成本低效率高,但是安全性较低。

**2. SOAP**

SOAP是一种数据交换协议规范,是一种轻量的、简单的、基于XML的协议的规范。而SOAP可以看着是一个重量级的协议，基于XML、SOAP在安全方面是通过使用XML-Security和XML-Signature两个规范组成了WS-Security来实现安全控制的,当前已经得到了各个厂商的支持 。

它有什么优点？简单总结为：易用、灵活、跨语言、跨平台。

**3. SOA**

面向服务架构，它可以根据需求通过网络对松散耦合的粗粒度应用组件进行分布式部署、组合和使用。服务层是SOA的基础，可以直接被应用调用，从而有效控制系统中与软件代理交互的人为依赖性。

SOA是一种粗粒度、松耦合服务架构，服务之间通过简单、精确定义接口进行通讯，不涉及底层编程接口和通讯模型。SOA可以看作是B/S模型、XML（标准通用标记语言的子集）/Web Service技术之后的自然延伸。

**4. REST 和 SOAP、RPC 有何区别呢?**

没什么太大区别，他们的本质都是提供可支持分布式的基础服务，最大的区别在于他们各自的的特点所带来的不同应用场景 。

## 5. RPC框架需要解决的问题？

- 如何确定客户端和服务端之间的通信协议？
- 如何更高效地进行网络通信？
- 服务端提供的服务如何暴露给客户端？
- 客户端如何发现这些暴露的服务？
- 如何更高效地对请求对象和响应结果进行序列化和反序列化操作？

## 6. RPC的实现基础

需要有非常高效的网络通信，比如一般选择Netty作为网络通信框架；需要有比较高效的序列化框架，比如谷歌的Protobuf序列化框架；可靠的寻址方式（主要是提供服务的发现），比如可以使用Zookeeper来注册服务等等；如果是带会话（状态）的RPC调用，还需要有会话和状态保持的功能；

## 7. RPC使用了哪些关键技术？

1. 动态代理

生成Client Stub（客户端存根）和Server Stub（服务端存根）的时候需要用到Java动态代理技术，可以使用JDK提供的原生的动态代理机制，也可以使用开源的：CGLib代理，Javassist字节码生成技术。

2. 序列化和反反序列化

在网络中，所有的数据都将会被转化为字节进行传送，所以为了能够使参数对象在网络中进行传输，需要对这些参数进行序列化和反序列化操作。

序列化：把对象转换为字节序列的过程称为对象的序列化，也就是编码的过程。

反序列化：把字节序列恢复为对象的过程称为对象的反序列化，也就是解码的过程。

目前比较高效的开源序列化框架：如Kryo、FastJson和Protobuf等。

3. NIO通信

出于并发性能的考虑，传统的阻塞式 IO 显然不太合适，因此我们需要异步的 IO，即 NIO。Java 提供了 NIO 的解决方案，Java 7 也提供了更优秀的 NIO.2 支持。可以选择Netty或者MINA来解决NIO数据传输的问题。

4. 服务注册中心

可选：Redis、Zookeeper、Consul 、Etcd。一般使用ZooKeeper提供服务注册与发现功能，解决单点故障以及分布式部署的问题(注册中心)。

## 8. RPC的实现原理架构图

![RPC原理架构](https://ws1.sinaimg.cn/large/005CDUpdgy1g8ff8qa46kj30dl08kdg9.jpg)

![RPC调用过程](https://ws1.sinaimg.cn/large/005CDUpdgy1g8ff93m7b5j30fa0b4wf5.jpg)

也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。

比如说，A服务器想调用B服务器上的一个方法：

User getUserByName(String userName)

1. 建立通信

首先要解决通讯的问题：即A机器想要调用B机器，首先得建立起通信连接。主要是通过在客户端和服务器之间建立TCP连接，远程过程调用的所有交换的数据都在这个连接里传输。连接可以是按需连接，调用结束后就断掉，也可以是长连接，多个远程过程调用共享同一个连接。

通常这个连接可以是按需连接（需要调用的时候就先建立连接，调用结束后就立马断掉），也可以是长连接（客户端和服务器建立起连接之后保持长期持有，不管此时有无数据包的发送，可以配合心跳检测机制定期检测建立的连接是否存活有效），多个远程过程调用共享同一个连接。

2. 服务寻址

要解决寻址的问题，也就是说，A服务器上的应用怎么告诉底层的RPC框架，如何连接到B服务器（如主机或IP地址）以及特定的端口，方法的名称名称是什么。

通常情况下我们需要提供B机器（主机名或IP地址）以及特定的端口，然后指定调用的方法或者函数的名称以及入参出参等信息，这样才能完成服务的一个调用。可靠的寻址方式（主要是提供服务的发现）是RPC的实现基石，比如可以采用Redis或者Zookeeper来注册服务等等。

**2.1 从服务提供者的角度**

- 当服务提供者启动的时候，需要将自己提供的服务注册到指定的注册中心，以便服务消费者能够通过服务注册中心进行查找；
- 当服务提供者由于各种原因致使提供的服务停止时，需要向注册中心注销停止的服务；
- 服务的提供者需要定期向服务注册中心发送心跳检测，服务注册中心如果一段时间未收到来自服务提供者的心跳后，认为该服务提供者已经停止服务，则将该服务从注册中心上去掉。

**2.2 从调用者的角度看**

- 服务的调用者启动的时候根据自己订阅的服务向服务注册中心查找服务提供者的地址等信息；
- 当服务调用者消费的服务上线或者下线的时候，注册中心会告知该服务的调用者；
- 服务调用者下线的时候，则取消订阅。

3. 网络传输

**3.1 序列化** 

当A机器上的应用发起一个RPC调用时，调用方法和其入参等信息需要通过底层的网络协议如TCP传输到B机器，由于网络协议是基于二进制的，所有我们传输的参数数据都需要先进行序列化（Serialize）或者编组（marshal）成二进制的形式才能在网络中进行传输。然后通过寻址操作和网络传输将序列化或者编组之后的二进制数据发送给B机器。

**3.2 反序列化**

当B机器接收到A机器的应用发来的请求之后，又需要对接收到的参数等信息进行反序列化操作（序列化的逆操作），即将二进制信息恢复为内存中的表达方式，然后再找到对应的方法（寻址的一部分）进行本地调用（一般是通过生成代理Proxy去调用,通常会有JDK动态代理、CGLIB动态代理、Javassist生成字节码技术等），之后得到调用的返回值。

4. 服务调用

B机器进行本地调用（通过代理Proxy和反射调用）之后得到了返回值，此时还需要再把返回值发送回A机器，同样也需要经过序列化操作，然后再经过网络传输将二进制数据发送回A机器，而当A机器接收到这些返回值之后，则再次进行反序列化操作，恢复为内存中的表达方式，最后再交给A机器上的应用进行相关处理（一般是业务逻辑处理操作）。

**参考文章**：

[RPC基本原理介绍](https://www.cnblogs.com/javafirst0/p/10728852.html)
