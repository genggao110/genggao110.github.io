---
layout:     post
title:      "剑指offer"
subtitle:   " \"算法题解\""
date:       2019-06-22 15:37:00
author:     "Ming"
catalog: true
header-img: "img/post-bg-girl.jpg"
tags:
    - 算法题解
---

> "Limitations live only in our minds. But if we use our imaginations, our possibilities become limitless."

### 1. 二维数组的查找

**题目描述**

在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

**解决思路**：

> 思路1： 将每一行看成是有序递增的数组，利用二分查找，通过遍历每一行得到答案，时间复杂度是nlogn。

```java
public boolean Find(int target, int [][] array) {
        boolean result = false;
        int rows = array.length;
        for(int i = 0; i < rows; i++){
            //1. 可以利用Arrays.binarySearch方法
            // int status = Arrays.binarySearch(array[i], target);
            // if(status >= 0){
            //     result = true;
            //     break;
            // }

            //2. 自己实现二分查找
            int low = 0;
            int high = array[i].length - 1;
            while(low <= high){
                int mid = (low + high) >> 1;
                if(target > array[i][mid])
                    low = mid + 1;
                else if(target < array[i][mid])
                    high = mid - 1;
                else
                    return true;
            }

        }
        return result;
    }
```

> 思路2： 因为矩阵是有序的，从左下角来看，向上数字递减，向右数字递增。所以从左下角元素往上查找，右边元素是比这个元素打，上边的元素是比这个元素小。所以，target比这个元素小就往上找，比这个元素大就往右找。如果出了边界，则说明二维数组中不存在target这个元素。

```java
public boolean Find(int target, int [][] array) {
        int rows = array.length;
        int cols = array[0].length;
        int i=rows-1,j=0;
        while(i>=0 && j<cols){
            if(target<array[i][j])
                i--;
            else if(target>array[i][j])
                j++;
            else
                return true;
        }
        return false;
    }
```

### 2. 替换空格

**题目描述**

请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

**解决思路**：(很明显，这里不是考察java的replaceAll函数，那样将毫无意义)

> 思路1：利用StringBuilder/StringBuffer的append拼接函数(将字符串转换为字符数组，再将字符进行拼接与之同样道理)

```java
public static String replaceSpace(StringBuffer str){
        if(str == null) return null;
        StringBuilder sb = new StringBuilder();
        for(int i = 0; i < str.length(); i++){
            if(String.valueOf(str.charAt(i)).equals(" ")){
                sb.append("%20");
            }else{
                sb.append(str.charAt(i));
            }
        }
        return sb.toString();
    }
```

> 思路2： 我们先遍历一次字符串，找到字符串中空格的数目，然后计算出替换后的新字符串的长度，每替换一个空格，字符串长度增加2(这里使用str.setLength()方法来扩大str的长度，也可以通过当每次遍历到一个空格时，在字符串尾部填充两个任意字符使得字符串的长度等于替换后的长度)。然后我们从字符串后面开始复制，准备两个指针，indexOld和indexNew。indexNew指向新字符串的末尾，indexOld指向旧字符串的末尾。通过向前移动indexOld完成字符复制的过程，每个字符只需要移动一次，效率会更高一点。

```java
public static String replaceSpace(StringBuffer str){
        if(str == null || str.length() <= 0){
            return "";
        }
        int spaceNum = 0; //统计字符串出现空格的次数
        for(int i = 0; i < str.length(); i++){
            if(str.charAt(i) == ' ')
                spaceNum++;
        }
        int indexOld = str.length() - 1; //indexOld为替换前的str下标
        int newLength = str.length() + 2 * spaceNum; //计算空格换成%20之后的str下标
        int indexNew = newLength - 1; //indexNew为把空格替换为%20之后的str下标
        str.setLength(newLength); //使得str的长度扩大到转换成%20之后的长度，防止下标越界
        for(;indexOld >= 0 && indexOld < indexNew;--indexOld){
            if(str.charAt(indexOld) == ' '){
                str.setCharAt(indexNew--, '0');
                str.setCharAt(indexNew--, '2');
                str.setCharAt(indexNew--, '%');
            }else{
                str.setCharAt(indexNew--, str.charAt(indexOld));
            }
        }
        return str.toString();
    }
```

### 3. 从尾到头打印链表

**题目描述**

输入一个链表，按链表值从尾到头的顺序返回一个ArrayList.

**解题思路**：

> 思路1：当我看到题目第一眼，脑海里想的是这其实就是一个翻转问题，要么翻转链表，要么对遍历链表后的ArrayList进行翻转,所以我给出了下面的解决方案：

```java
public ArrayList<Integer> printListFromTailToHead(ListNode listNode){
        ArrayList<Integer> temp = new ArrayList<Integer>();
        if(listNode == null){
            return temp;
        }
        if(listNode.next == null){
            temp.add(listNode.val);
            return temp;
        }
        ListNode tempNode = listNode;
        while(tempNode != null){
            temp.add(tempNode.val);
            tempNode = tempNode.next;
        }
        Collections.reverse(temp); //利用java.util.Collections类
        return temp;
    }
```

> 思路2： 链表反转(刚好这里说一下利用迭代法反转单链表的思路——所谓的单链表反转，就是把每个节点的指针域由原来的指向下一个节点变为指向前一个节点。但是由于单链表没有指向前一个节点的指针域，因此我们需要增加一个指向前一个节点的指针pre,用于存储每一个节点的前一个节点。此外，还需要定义一个保存当前节点的指针cur,以及下一个节点的next。定义好这三个指针后，遍历单链表，将当前节点的指针域指向前一个节点，之后将定义三个指针往后移动，直至遍历到最后一个节点停止。)再依次遍历链表存储到ArrayList.

[单链表反转-详细过程图解](https://www.jianshu.com/p/34ba48bddae1)

```java
public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        ArrayList<Integer> list = new ArrayList<Integer>();
        ListNode pre = null; //前一个节点指针
        ListNode cur = listNode;
        ListNode next = null; //下一个节点指针
        while(cur != null){
            next = cur.next; //next 指向下一个节点
            cur.next = pre; //将当前节点的next域指向前一个节点
            pre = cur;  // pre指针向后面移动
            cur = next; // cur指针向后面移动
        }
        //遍历链表获取结果
        while(pre != null){
            list.add(pre.val);
            pre = pre.next;
        }
        return list;
    }
```

> 思路3：借助于栈的先进后出特点，遍历的时候入栈，完了弹栈加入到ArrayList中。

```java
public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        ArrayList<Integer> list = new ArrayList<Integer>();
        Deque<Integer> stack = new ArrayDeque<Integer>();
        while (listNode != null){
            stack.push(listNode.val);
            listNode = listNode.next;
        }
        while(!stack.isEmpty()){
            list.add(stack.pop());
        }
        return list;
    }
```

> 思路4： 递归解法，本质上其实也是一个栈结构，要实现反过来输出链表，我们每访问到一个节点的时候，先递归输出它后面的节点，再输出该节点本身极客。

```java
public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        ArrayList<Integer> list = new ArrayList<>();
        helper(list,listNode);
        return list;
    }

private void helper(ArrayList<Integer> res, ListNode head){
        if(head != null){
            if(head.next != null){
                helper(res,head.next);
            }
            res.add(head.val);
        }
    }
```

### 4.