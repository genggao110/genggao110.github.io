---
layout:     post
title:      "剑指offer"
subtitle:   " \"算法题解\""
date:       2019-06-22 15:37:00
author:     "Ming"
catalog: true
header-img: "img/post-bg-girl.jpg"
tags:
    - 算法题解
---

> "Limitations live only in our minds. But if we use our imaginations, our possibilities become limitless."

### 1. 二维数组的查找

**题目描述**

在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

**解决思路**：

> 思路1： 将每一行看成是有序递增的数组，利用二分查找，通过遍历每一行得到答案，时间复杂度是nlogn。

```java
public boolean Find(int target, int [][] array) {
        boolean result = false;
        int rows = array.length;
        for(int i = 0; i < rows; i++){
            //1. 可以利用Arrays.binarySearch方法
            // int status = Arrays.binarySearch(array[i], target);
            // if(status >= 0){
            //     result = true;
            //     break;
            // }

            //2. 自己实现二分查找
            int low = 0;
            int high = array[i].length - 1;
            while(low <= high){
                int mid = (low + high) >> 1;
                if(target > array[i][mid])
                    low = mid + 1;
                else if(target < array[i][mid])
                    high = mid - 1;
                else
                    return true;
            }

        }
        return result;
    }
```

> 思路2： 因为矩阵是有序的，从左下角来看，向上数字递减，向右数字递增。所以从左下角元素往上查找，右边元素是比这个元素打，上边的元素是比这个元素小。所以，target比这个元素小就往上找，比这个元素大就往右找。如果出了边界，则说明二维数组中不存在target这个元素。

```java
public boolean Find(int target, int [][] array) {
        int rows = array.length;
        int cols = array[0].length;
        int i=rows-1,j=0;
        while(i>=0 && j<cols){
            if(target<array[i][j])
                i--;
            else if(target>array[i][j])
                j++;
            else
                return true;
        }
        return false;
    }
```

### 2. 替换空格

**题目描述**

请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

**解决思路**：(很明显，这里不是考察java的replaceAll函数，那样将毫无意义)

> 思路1：利用StringBuilder/StringBuffer的append拼接函数(将字符串转换为字符数组，再将字符进行拼接与之同样道理)

```java
public static String replaceSpace(StringBuffer str){
        if(str == null) return null;
        StringBuilder sb = new StringBuilder();
        for(int i = 0; i < str.length(); i++){
            if(String.valueOf(str.charAt(i)).equals(" ")){
                sb.append("%20");
            }else{
                sb.append(str.charAt(i));
            }
        }
        return sb.toString();
    }
```

> 思路2： 我们先遍历一次字符串，找到字符串中空格的数目，然后计算出替换后的新字符串的长度，每替换一个空格，字符串长度增加2(这里使用str.setLength()方法来扩大str的长度，也可以通过当每次遍历到一个空格时，在字符串尾部填充两个任意字符使得字符串的长度等于替换后的长度)。然后我们从字符串后面开始复制，准备两个指针，indexOld和indexNew。indexNew指向新字符串的末尾，indexOld指向旧字符串的末尾。通过向前移动indexOld完成字符复制的过程，每个字符只需要移动一次，效率会更高一点。

```java
public static String replaceSpace(StringBuffer str){
        if(str == null || str.length() <= 0){
            return "";
        }
        int spaceNum = 0; //统计字符串出现空格的次数
        for(int i = 0; i < str.length(); i++){
            if(str.charAt(i) == ' ')
                spaceNum++;
        }
        int indexOld = str.length() - 1; //indexOld为替换前的str下标
        int newLength = str.length() + 2 * spaceNum; //计算空格换成%20之后的str下标
        int indexNew = newLength - 1; //indexNew为把空格替换为%20之后的str下标
        str.setLength(newLength); //使得str的长度扩大到转换成%20之后的长度，防止下标越界
        for(;indexOld >= 0 && indexOld < indexNew;--indexOld){
            if(str.charAt(indexOld) == ' '){
                str.setCharAt(indexNew--, '0');
                str.setCharAt(indexNew--, '2');
                str.setCharAt(indexNew--, '%');
            }else{
                str.setCharAt(indexNew--, str.charAt(indexOld));
            }
        }
        return str.toString();
    }
```

### 3. 从尾到头打印链表

**题目描述**

输入一个链表，按链表值从尾到头的顺序返回一个ArrayList.

**解题思路**：

> 思路1：当我看到题目第一眼，脑海里想的是这其实就是一个翻转问题，要么翻转链表，要么对遍历链表后的ArrayList进行翻转,所以我给出了下面的解决方案：

```java
public ArrayList<Integer> printListFromTailToHead(ListNode listNode){
        ArrayList<Integer> temp = new ArrayList<Integer>();
        if(listNode == null){
            return temp;
        }
        if(listNode.next == null){
            temp.add(listNode.val);
            return temp;
        }
        ListNode tempNode = listNode;
        while(tempNode != null){
            temp.add(tempNode.val);
            tempNode = tempNode.next;
        }
        Collections.reverse(temp); //利用java.util.Collections类
        return temp;
    }
```

> 思路2： 链表反转(刚好这里说一下利用迭代法反转单链表的思路——所谓的单链表反转，就是把每个节点的指针域由原来的指向下一个节点变为指向前一个节点。但是由于单链表没有指向前一个节点的指针域，因此我们需要增加一个指向前一个节点的指针pre,用于存储每一个节点的前一个节点。此外，还需要定义一个保存当前节点的指针cur,以及下一个节点的next。定义好这三个指针后，遍历单链表，将当前节点的指针域指向前一个节点，之后将定义三个指针往后移动，直至遍历到最后一个节点停止。)再依次遍历链表存储到ArrayList.

[单链表反转-详细过程图解](https://www.jianshu.com/p/34ba48bddae1)

```java
public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        ArrayList<Integer> list = new ArrayList<Integer>();
        ListNode pre = null; //前一个节点指针
        ListNode cur = listNode;
        ListNode next = null; //下一个节点指针
        while(cur != null){
            next = cur.next; //next 指向下一个节点
            cur.next = pre; //将当前节点的next域指向前一个节点
            pre = cur;  // pre指针向后面移动
            cur = next; // cur指针向后面移动
        }
        //遍历链表获取结果
        while(pre != null){
            list.add(pre.val);
            pre = pre.next;
        }
        return list;
    }
```

> 思路3：借助于栈的先进后出特点，遍历的时候入栈，完了弹栈加入到ArrayList中。

```java
public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        ArrayList<Integer> list = new ArrayList<Integer>();
        Deque<Integer> stack = new ArrayDeque<Integer>();
        while (listNode != null){
            stack.push(listNode.val);
            listNode = listNode.next;
        }
        while(!stack.isEmpty()){
            list.add(stack.pop());
        }
        return list;
    }
```

> 思路4： 递归解法，本质上其实也是一个栈结构，要实现反过来输出链表，我们每访问到一个节点的时候，先递归输出它后面的节点，再输出该节点本身即可。

```java
public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        ArrayList<Integer> list = new ArrayList<>();
        helper(list,listNode);
        return list;
    }

private void helper(ArrayList<Integer> res, ListNode head){
        if(head != null){
            if(head.next != null){
                helper(res,head.next);
            }
            res.add(head.val);
        }
    }
```

### 4. 重建二叉树

**题目描述**

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假如输入的前序遍历和后序遍历的结果都不包含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6},则重建二叉树并返回。

**解题思路**：(二叉树天然的递归特性，使得我们可以利用递归算法对二叉树进行遍历和重建)

> 思路1：在二叉树的前序遍历序列(`根-左-右`)中，第一个数字总是树的根节点的值。但在中序遍历序列(`左-根-右`)中，根节点的值在序列的中间，左子树的节点的值位于根节点的值得左边，而右子树的节点的值位于根节点的值的右边。因此，我们需要扫描中序遍历序列，确定出左右子树。以给出的题目为例子：前序遍历序列的第一个数字1就是根节点的值。扫描中序遍历序列，就能确定根节点的值的位置，根据中序遍历的特点，在根节点的值1前面的3个数字都是左子树节点的值，位于1后面的数字都是右子树节点的值。由于在中序遍历序列中，有3个数字是左子树节点的值，因此左子树总共有3个左子节点。同样，在前序遍历的系列中，根节点后面的3个数字就是3个左子树节点的值，再后面的所有数字就是右子树节点的值。**所以**，这样就在前序和中序遍历的两个序列中，分别找到了左右子树对应的子序列。我们已经分别找到了左右子树的前序遍历和中序遍历，这样我们就可以用同样的办法去构建左右子树，实现递归。

```java
    public TreeNode reConstuctBinaryTree(int[] pre, int[] in){
        TreeNode root = reConstructBinaryTree(pre,0, pre.length - 1,in, 0, in.length - 1);
        return root;
    }

    //前序遍历{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}
    private TreeNode reConstructBinaryTree(int[] pre, int preStart, int preEnd, int[] in, int inStart, int inEnd){
        if(preStart > preEnd || inStart > inEnd){
            return null;
        }
        TreeNode root = new TreeNode(pre[preStart]); //根节点是数组的第一个
        for(int i = inStart; i <= inEnd; i++){
            if(in[i] == pre[preStart]){ //找到二叉树根节点
                //左子树，其中i- inStart为中序排序中左子树节点的个数，preStart + 它，就是前序中左子树结束节点在前序数组中的索引，i - 1就是中序的左子树末端节点索引
                root.left = reConstructBinaryTree(pre, preStart+1, preStart+i-inStart, in, inStart, i - 1);
                //右子树，类似，[前序最左节点的索引](i - inStart + preStart) + 1,为右子树根节点索引， i+1 为右子树的起始中序节点索引
                root.right = reConstructBinaryTree(pre, preStart + i - inStart + 1, preEnd, in, i+1, preEnd);
            }
        }
        return root;
    }
```
或许有些人说这个找起始索引的过程有点晕，为了让你稍微清晰的了解一下，我们可以通过在迭代过程中传入相当于提取出来的左右子树的方式(以内存空间增加的方法突出清晰的表现)，给出以下解题代码。(理论都是一样的)

```java
public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
       if(pre.length == 0 || in.length == 0){
            return null;
        }
        TreeNode node = new TreeNode(pre[0]);
        for(int i = 0; i < in.length; i++){
            if(pre[0] == in[i]){
                node.left = reConstructBinaryTree(Arrays.copyOfRange(pre, 1, i+1), Arrays.copyOfRange(in, 0, i));
                node.right = reConstructBinaryTree(Arrays.copyOfRange(pre, i+1, pre.length), Arrays.copyOfRange(in, i+1,in.length));
            }
        }
        return node;
    }
```
当然，还有一种优化策略，利用HashMap存储值和索引，使得查找根节点时速度加快。如下所示：
```java
import java.util.HashMap;
 
public class Solution {
    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        if(pre == null || in == null){
            return null;
        }
        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
        for(int i=0;i<in.length;i++){
            map.put(in[i],i);
        }
         
        return preIn(pre, 0, pre.length-1, in, 0, in.length-1, map);
    }
     
    public TreeNode preIn(int[] pre, int p1, int p2, int[] in, int i1, int i2, HashMap<Integer,Integer> map){
        if(p1>p2){
            return null;
        }
        TreeNode parent = new TreeNode(pre[p1]);
        int parentInIndex = map.get(pre[p1]);
        parent.left = preIn(pre, p1+1, p1+parentInIndex-i1, in, i1, parentInIndex-1, map);
        parent.right = preIn(pre, p1+parentInIndex-i1+1, p2, in, parentInIndex+1, i2, map);
        return parent;
    }
}
```
那么，除了这种递归调用的方法之外，有没有别的方法来解决这个问题呢？给出思路2的解法如下：

> 思路2：让前序遍历的序列拥有中序遍历的索引，在遍历(前序遍历)的过程中按照二叉排序树的方法插入即可。

**原理解释**：(参考自(数据结构：关于重建二叉树的三种思路)[https://blog.csdn.net/lemon_tree12138/article/details/49798221])

给出具体数据的例子如下所示：
- 前序： A B D E H I C F G
- 中序： D B H E I A F C G

![前序遍历](https://ws1.sinaimg.cn/large/005CDUpdly1g50dyx7ognj30lk0bn3zr.jpg)

![中序遍历过程](https://ws1.sinaimg.cn/large/005CDUpdgy1g50dzu7rpnj30na0bfab5.jpg)

![后序遍历过程](https://ws1.sinaimg.cn/large/005CDUpdgy1g50e0eqx90j30mz0c8q40.jpg)

则让前序遍历拥有中序遍历的索引表如下所示(Index很直观，就是取了某一个节点的下标，并保存)：

 序号 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8
 --- | --- | --- | --- | --- | --- | --- | --- | --- | --- 
 前序 | A | B | D | E | H | I | C | F | G
 INDEX | 5 | 1 | 0 | 3 | 2 | 4 | 7 | 6 | 8
 中序 | D | B | H | E | I | A | F | C | G

其实在已知的遍历序列中，如果含有中序遍历结果，那么我们都可以直接采用上面的这种创建索引函数的方式来简化重建过程。具体原因解释之前我们先来看一下下图：

![二叉树中序遍历顺序示意图](https://ws1.sinaimg.cn/large/005CDUpdgy1g50e1lle4aj30pc079wfu.jpg)

我们可以把之前的中序遍历二叉树过程平摊开，就可以获取上图这样的一个顺序序列。从上图我们可以发现这样一个现象，**那就是某一个节点的左孩子一定是在这个节点的左边，其右孩子一定是在这个节点的右边(中序遍历的定义)，也就是节点Node的左孩子left的值(index)一定是比Node的值小，而Node右孩子Right的值一定是比Node的值大。**

很明显，二叉排序树正是这样定义的。这样，我们来看一下二叉树的前序遍历。因为是前序，所以我们在遍历节点Node的孩子节点之前，必定是已经遍历过Node节点。这样也可以理解成是一种临近遍历的过程。这样前序 + 中序 = 二叉排序树，所以我们可以重建二叉排序树。(延伸到该题，解法代码如下所示：)

```java
import java.util.*;
public class Solution {
    TreeNode root = null;
    Map<Integer,Integer> indexMap = new HashMap<>();
    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        int[] index = recordArray(pre, in);
        if(root == null){
            root = new TreeNode(pre[0]);
        }
        //构建前序遍历元素与索引之间的映射
        for(int i = 0; i < pre.length; i++){
            indexMap.put(pre[i],index[i]);
            TreeNode insertNode = new TreeNode(pre[i]);
            insert(insertNode);
        }
        return root;
    }
    
    private void insert(TreeNode insertNode){
        TreeNode currentNode = root;
        while(true){
            if(indexMap.get(insertNode.val) < indexMap.get(currentNode.val)){
                if(currentNode.left == null){
                    currentNode.left = insertNode;
                    break;
                }else {
                    currentNode = currentNode.left;
                }
            }else if(indexMap.get(insertNode.val) > indexMap.get(currentNode.val)){
                if(currentNode.right == null){
                    currentNode.right = insertNode;
                    break;
                }else{
                    currentNode = currentNode.right;
                }
            }else{
                break;
            }
        }
    }

    private int[] recordArray(int[] pre, int[] in){
        if(pre == null || pre.length == 0 || in == null || in.length == 0){
            return null;
        }
        int[] record = new int[pre.length];

        for(int i = 0; i < pre.length; i++){
            record[i] = index(in, pre[i]);
        }
        return record;
    }

    //计算前序遍历元素在中序遍历数组中的位置
    private int index(int[] in, int label){
        for(int i = 0; i < in.length; i++){
            if(label == in[i]){
                return i;
            }
        }
        return -1;
    }
}
```

最后，补充一下关于二叉树的一些相关概念：

[Leetcode——二叉树常考算法整理](https://blog.csdn.net/qq_32690999/article/details/80484440)

### 5. 
