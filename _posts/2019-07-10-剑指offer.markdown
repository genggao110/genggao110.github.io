---
layout:     post
title:      "剑指offer"
subtitle:   " \"算法题解\""
date:       2019-06-22 15:37:00
author:     "Ming"
catalog: true
header-img: "img/post-bg-girl.jpg"
tags:
    - 算法题解
---

> "Limitations live only in our minds. But if we use our imaginations, our possibilities become limitless."

### 1. 二维数组的查找

**题目描述**

在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

**解决思路**：

> 思路1： 将每一行看成是有序递增的数组，利用二分查找，通过遍历每一行得到答案，时间复杂度是nlogn。

```java
public boolean Find(int target, int [][] array) {
        boolean result = false;
        int rows = array.length;
        for(int i = 0; i < rows; i++){
            //1. 可以利用Arrays.binarySearch方法
            // int status = Arrays.binarySearch(array[i], target);
            // if(status >= 0){
            //     result = true;
            //     break;
            // }

            //2. 自己实现二分查找
            int low = 0;
            int high = array[i].length - 1;
            while(low <= high){
                int mid = (low + high) >> 1;
                if(target > array[i][mid])
                    low = mid + 1;
                else if(target < array[i][mid])
                    high = mid - 1;
                else
                    return true;
            }

        }
        return result;
    }
```

> 思路2： 因为矩阵是有序的，从左下角来看，向上数字递减，向右数字递增。所以从左下角元素往上查找，右边元素是比这个元素打，上边的元素是比这个元素小。所以，target比这个元素小就往上找，比这个元素大就往右找。如果出了边界，则说明二维数组中不存在target这个元素。

```java
public boolean Find(int target, int [][] array) {
        int rows = array.length;
        int cols = array[0].length;
        int i=rows-1,j=0;
        while(i>=0 && j<cols){
            if(target<array[i][j])
                i--;
            else if(target>array[i][j])
                j++;
            else
                return true;
        }
        return false;
    }
```

### 2. 替换空格

**题目描述**

请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

**解决思路**：(很明显，这里不是考察java的replaceAll函数，那样将毫无意义)

> 思路1：利用StringBuilder/StringBuffer的append拼接函数(将字符串转换为字符数组，再将字符进行拼接与之同样道理)

```java
public static String replaceSpace(StringBuffer str){
        if(str == null) return null;
        StringBuilder sb = new StringBuilder();
        for(int i = 0; i < str.length(); i++){
            if(String.valueOf(str.charAt(i)).equals(" ")){
                sb.append("%20");
            }else{
                sb.append(str.charAt(i));
            }
        }
        return sb.toString();
    }
```

> 思路2： 我们先遍历一次字符串，找到字符串中空格的数目，然后计算出替换后的新字符串的长度，每替换一个空格，字符串长度增加2(这里使用str.setLength()方法来扩大str的长度，也可以通过当每次遍历到一个空格时，在字符串尾部填充两个任意字符使得字符串的长度等于替换后的长度)。然后我们从字符串后面开始复制，准备两个指针，indexOld和indexNew。indexNew指向新字符串的末尾，indexOld指向旧字符串的末尾。通过向前移动indexOld完成字符复制的过程，每个字符只需要移动一次，效率会更高一点。

```java
public static String replaceSpace(StringBuffer str){
        if(str == null || str.length() <= 0){
            return "";
        }
        int spaceNum = 0; //统计字符串出现空格的次数
        for(int i = 0; i < str.length(); i++){
            if(str.charAt(i) == ' ')
                spaceNum++;
        }
        int indexOld = str.length() - 1; //indexOld为替换前的str下标
        int newLength = str.length() + 2 * spaceNum; //计算空格换成%20之后的str下标
        int indexNew = newLength - 1; //indexNew为把空格替换为%20之后的str下标
        str.setLength(newLength); //使得str的长度扩大到转换成%20之后的长度，防止下标越界
        for(;indexOld >= 0 && indexOld < indexNew;--indexOld){
            if(str.charAt(indexOld) == ' '){
                str.setCharAt(indexNew--, '0');
                str.setCharAt(indexNew--, '2');
                str.setCharAt(indexNew--, '%');
            }else{
                str.setCharAt(indexNew--, str.charAt(indexOld));
            }
        }
        return str.toString();
    }
```

### 3. 从尾到头打印链表

**题目描述**

输入一个链表，按链表值从尾到头的顺序返回一个ArrayList.

**解题思路**：

> 思路1：当我看到题目第一眼，脑海里想的是这其实就是一个翻转问题，要么翻转链表，要么对遍历链表后的ArrayList进行翻转,所以我给出了下面的解决方案：

```java
public ArrayList<Integer> printListFromTailToHead(ListNode listNode){
        ArrayList<Integer> temp = new ArrayList<Integer>();
        if(listNode == null){
            return temp;
        }
        if(listNode.next == null){
            temp.add(listNode.val);
            return temp;
        }
        ListNode tempNode = listNode;
        while(tempNode != null){
            temp.add(tempNode.val);
            tempNode = tempNode.next;
        }
        Collections.reverse(temp); //利用java.util.Collections类
        return temp;
    }
```

> 思路2： 链表反转(刚好这里说一下利用迭代法反转单链表的思路——所谓的单链表反转，就是把每个节点的指针域由原来的指向下一个节点变为指向前一个节点。但是由于单链表没有指向前一个节点的指针域，因此我们需要增加一个指向前一个节点的指针pre,用于存储每一个节点的前一个节点。此外，还需要定义一个保存当前节点的指针cur,以及下一个节点的next。定义好这三个指针后，遍历单链表，将当前节点的指针域指向前一个节点，之后将定义三个指针往后移动，直至遍历到最后一个节点停止。)再依次遍历链表存储到ArrayList.

[单链表反转-详细过程图解](https://www.jianshu.com/p/34ba48bddae1)

```java
public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        ArrayList<Integer> list = new ArrayList<Integer>();
        ListNode pre = null; //前一个节点指针
        ListNode cur = listNode;
        ListNode next = null; //下一个节点指针
        while(cur != null){
            next = cur.next; //next 指向下一个节点
            cur.next = pre; //将当前节点的next域指向前一个节点
            pre = cur;  // pre指针向后面移动
            cur = next; // cur指针向后面移动
        }
        //遍历链表获取结果
        while(pre != null){
            list.add(pre.val);
            pre = pre.next;
        }
        return list;
    }
```

> 思路3：借助于栈的先进后出特点，遍历的时候入栈，完了弹栈加入到ArrayList中。

```java
public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        ArrayList<Integer> list = new ArrayList<Integer>();
        Deque<Integer> stack = new ArrayDeque<Integer>();
        while (listNode != null){
            stack.push(listNode.val);
            listNode = listNode.next;
        }
        while(!stack.isEmpty()){
            list.add(stack.pop());
        }
        return list;
    }
```

> 思路4： 递归解法，本质上其实也是一个栈结构，要实现反过来输出链表，我们每访问到一个节点的时候，先递归输出它后面的节点，再输出该节点本身即可。

```java
public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        ArrayList<Integer> list = new ArrayList<>();
        helper(list,listNode);
        return list;
    }

private void helper(ArrayList<Integer> res, ListNode head){
        if(head != null){
            if(head.next != null){
                helper(res,head.next);
            }
            res.add(head.val);
        }
    }
```

### 4. 重建二叉树

**题目描述**

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假如输入的前序遍历和后序遍历的结果都不包含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6},则重建二叉树并返回。

**解题思路**：(二叉树天然的递归特性，使得我们可以利用递归算法对二叉树进行遍历和重建)

> 思路1：在二叉树的前序遍历序列(`根-左-右`)中，第一个数字总是树的根节点的值。但在中序遍历序列(`左-根-右`)中，根节点的值在序列的中间，左子树的节点的值位于根节点的值得左边，而右子树的节点的值位于根节点的值的右边。因此，我们需要扫描中序遍历序列，确定出左右子树。以给出的题目为例子：前序遍历序列的第一个数字1就是根节点的值。扫描中序遍历序列，就能确定根节点的值的位置，根据中序遍历的特点，在根节点的值1前面的3个数字都是左子树节点的值，位于1后面的数字都是右子树节点的值。由于在中序遍历序列中，有3个数字是左子树节点的值，因此左子树总共有3个左子节点。同样，在前序遍历的系列中，根节点后面的3个数字就是3个左子树节点的值，再后面的所有数字就是右子树节点的值。**所以**，这样就在前序和中序遍历的两个序列中，分别找到了左右子树对应的子序列。我们已经分别找到了左右子树的前序遍历和中序遍历，这样我们就可以用同样的办法去构建左右子树，实现递归。

```java
    public TreeNode reConstuctBinaryTree(int[] pre, int[] in){
        TreeNode root = reConstructBinaryTree(pre,0, pre.length - 1,in, 0, in.length - 1);
        return root;
    }

    //前序遍历{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}
    private TreeNode reConstructBinaryTree(int[] pre, int preStart, int preEnd, int[] in, int inStart, int inEnd){
        if(preStart > preEnd || inStart > inEnd){
            return null;
        }
        TreeNode root = new TreeNode(pre[preStart]); //根节点是数组的第一个
        for(int i = inStart; i <= inEnd; i++){
            if(in[i] == pre[preStart]){ //找到二叉树根节点
                //左子树，其中i- inStart为中序排序中左子树节点的个数，preStart + 它，就是前序中左子树结束节点在前序数组中的索引，i - 1就是中序的左子树末端节点索引
                root.left = reConstructBinaryTree(pre, preStart+1, preStart+i-inStart, in, inStart, i - 1);
                //右子树，类似，[前序最左节点的索引](i - inStart + preStart) + 1,为右子树根节点索引， i+1 为右子树的起始中序节点索引
                root.right = reConstructBinaryTree(pre, preStart + i - inStart + 1, preEnd, in, i+1, preEnd);
            }
        }
        return root;
    }
```
或许有些人说这个找起始索引的过程有点晕，为了让你稍微清晰的了解一下，我们可以通过在迭代过程中传入相当于提取出来的左右子树的方式(以内存空间增加的方法突出清晰的表现)，给出以下解题代码。(理论都是一样的)

```java
public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
       if(pre.length == 0 || in.length == 0){
            return null;
        }
        TreeNode node = new TreeNode(pre[0]);
        for(int i = 0; i < in.length; i++){
            if(pre[0] == in[i]){
                node.left = reConstructBinaryTree(Arrays.copyOfRange(pre, 1, i+1), Arrays.copyOfRange(in, 0, i));
                node.right = reConstructBinaryTree(Arrays.copyOfRange(pre, i+1, pre.length), Arrays.copyOfRange(in, i+1,in.length));
            }
        }
        return node;
    }
```
当然，还有一种优化策略，利用HashMap存储值和索引，使得查找根节点时速度加快。如下所示：
```java
import java.util.HashMap;
 
public class Solution {
    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        if(pre == null || in == null){
            return null;
        }
        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
        for(int i=0;i<in.length;i++){
            map.put(in[i],i);
        }
         
        return preIn(pre, 0, pre.length-1, in, 0, in.length-1, map);
    }
     
    public TreeNode preIn(int[] pre, int p1, int p2, int[] in, int i1, int i2, HashMap<Integer,Integer> map){
        if(p1>p2){
            return null;
        }
        TreeNode parent = new TreeNode(pre[p1]);
        int parentInIndex = map.get(pre[p1]);
        parent.left = preIn(pre, p1+1, p1+parentInIndex-i1, in, i1, parentInIndex-1, map);
        parent.right = preIn(pre, p1+parentInIndex-i1+1, p2, in, parentInIndex+1, i2, map);
        return parent;
    }
}
```
那么，除了这种递归调用的方法之外，有没有别的方法来解决这个问题呢？给出思路2的解法如下：

> 思路2：让前序遍历的序列拥有中序遍历的索引，在遍历(前序遍历)的过程中按照二叉排序树的方法插入即可。

**原理解释**：(参考自(数据结构：关于重建二叉树的三种思路)[https://blog.csdn.net/lemon_tree12138/article/details/49798221])

给出具体数据的例子如下所示：
- 前序： A B D E H I C F G
- 中序： D B H E I A F C G

![前序遍历](https://ws1.sinaimg.cn/large/005CDUpdly1g50dyx7ognj30lk0bn3zr.jpg)

![中序遍历过程](https://ws1.sinaimg.cn/large/005CDUpdgy1g50dzu7rpnj30na0bfab5.jpg)

![后序遍历过程](https://ws1.sinaimg.cn/large/005CDUpdgy1g50e0eqx90j30mz0c8q40.jpg)

则让前序遍历拥有中序遍历的索引表如下所示(Index很直观，就是取了某一个节点的下标，并保存)：

 | 序号  | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   |
 | ----- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
 | 前序  | A   | B   | D   | E   | H   | I   | C   | F   | G   |
 | INDEX | 5   | 1   | 0   | 3   | 2   | 4   | 7   | 6   | 8   |
 | 中序  | D   | B   | H   | E   | I   | A   | F   | C   | G   |

其实在已知的遍历序列中，如果含有中序遍历结果，那么我们都可以直接采用上面的这种创建索引函数的方式来简化重建过程。具体原因解释之前我们先来看一下下图：

![二叉树中序遍历顺序示意图](https://ws1.sinaimg.cn/large/005CDUpdgy1g50e1lle4aj30pc079wfu.jpg)

我们可以把之前的中序遍历二叉树过程平摊开，就可以获取上图这样的一个顺序序列。从上图我们可以发现这样一个现象，**那就是某一个节点的左孩子一定是在这个节点的左边，其右孩子一定是在这个节点的右边(中序遍历的定义)，也就是节点Node的左孩子left的值(index)一定是比Node的值小，而Node右孩子Right的值一定是比Node的值大。**

很明显，二叉排序树正是这样定义的。这样，我们来看一下二叉树的前序遍历。因为是前序，所以我们在遍历节点Node的孩子节点之前，必定是已经遍历过Node节点。这样也可以理解成是一种临近遍历的过程。这样前序 + 中序 = 二叉排序树，所以我们可以重建二叉排序树。(延伸到该题，解法代码如下所示：)

```java
import java.util.*;
public class Solution {
    TreeNode root = null;
    Map<Integer,Integer> indexMap = new HashMap<>();
    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        int[] index = recordArray(pre, in);
        if(root == null){
            root = new TreeNode(pre[0]);
        }
        //构建前序遍历元素与索引之间的映射
        for(int i = 0; i < pre.length; i++){
            indexMap.put(pre[i],index[i]);
            TreeNode insertNode = new TreeNode(pre[i]);
            insert(insertNode);
        }
        return root;
    }
    
    private void insert(TreeNode insertNode){
        TreeNode currentNode = root;
        while(true){
            if(indexMap.get(insertNode.val) < indexMap.get(currentNode.val)){
                if(currentNode.left == null){
                    currentNode.left = insertNode;
                    break;
                }else {
                    currentNode = currentNode.left;
                }
            }else if(indexMap.get(insertNode.val) > indexMap.get(currentNode.val)){
                if(currentNode.right == null){
                    currentNode.right = insertNode;
                    break;
                }else{
                    currentNode = currentNode.right;
                }
            }else{
                break;
            }
        }
    }

    private int[] recordArray(int[] pre, int[] in){
        if(pre == null || pre.length == 0 || in == null || in.length == 0){
            return null;
        }
        int[] record = new int[pre.length];

        for(int i = 0; i < pre.length; i++){
            record[i] = index(in, pre[i]);
        }
        return record;
    }

    //计算前序遍历元素在中序遍历数组中的位置
    private int index(int[] in, int label){
        for(int i = 0; i < in.length; i++){
            if(label == in[i]){
                return i;
            }
        }
        return -1;
    }
}
```

最后，补充一下关于二叉树的一些相关概念：

[Leetcode——二叉树常考算法整理](https://blog.csdn.net/qq_32690999/article/details/80484440)

### 5. 用两个栈实现队列

**题目描述**

用两个栈来实现一个队列，完成队列的Push和Pop操作。队列中的元素为int类型。

**解题思路**：

> 两个栈stack1和stack2,开始时，每次添加队尾元素到stack1中。当弹出时，当 stack2 不为空，弹出 stack2 栈顶元素，如果 stack2 为空，将 stack1 中的全部数逐个出栈入栈 stack2，再弹出 stack2 栈顶元素。

![出入队列思路](https://ws1.sinaimg.cn/large/005CDUpdgy1g5yzkj3njjj30g706k762.jpg)

```java
import java.util.Stack;
 
public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();
     
    public void push(int node) {
        stack1.push(node);
    }
     
    public int pop() {
        if(stack1.empty()&&stack2.empty()){
            throw new RuntimeException("Queue is empty!");
        }
        if(stack2.empty()){
            while(!stack1.empty()){
                stack2.push(stack1.pop());
            }
        }
        return stack2.pop();
    }
}
```

### 6. 旋转数组的最小数字

**题目描述**

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1.(NOTE: 给出的所有元素都大于0，若数组大小为0，请返回0)。

**解题思路**：(非递减排序数组，很明显得出本题想要考的是二分法，但是为了展示解题的解法，这里给出几种解题的方法。)

**Note**: 非递减数组的含义是指对每一个元素均有array[i] <= array[i+1]。 

> 思路1：暴力法直接寻找，因为在两段范围内都是非递减排序，当不符合这个规律时，就找到了最小数字。

```java
import java.util.ArrayList;
public class Solution {
    public int minNumberInRotateArray(int [] array) {
        int n = array.length;
        if(n == 0){
            return 0;
        }
        for(int i=0;i<n-1;i++){
            if(array[i] >array[i+1]){
                return array[i+1];
            }
        }
        return array[0];
    }
}
```

> 思路2：排序法，利用Arrays工具类的排序函数，默认的排序规则是从小到大，排序后的数组的第一个值就是最小值。

```java
public int minNumberInRotateArray(int[] array){
    if(array.length == 0){
        return 0;
    }
    Arrays.sort(array);
    return array[0];
}
```

> 思路3：利用优先队列，将数组元素挨着丢进优先队列，优先队列默认为最小堆，弹出的第一个数就是整个数组的最小值。

```java
public int minNumberInRotateArray(int[] array){
    int n = array.length;
    if(n == 0) {
        return 0;
    }
    PriorityQueue<Integer> queue = new PriorityQueue<>();
    for(int i = 0; i < n; i++){
        queue.add(array[i]);
    }
    return queue.poll();
}
```

> 思路4：利用二分法进行求解。旋转后的数组实际上可以划分为两个有序的数组——前面子数组的大小都大于后面子数组中的元素。注意到实际上最小的元素就是两个子数组的分界线。本题目给出的数组在一定程度上是排序的，因此我们试着用二分查找法寻找这个最小的元素。

具体思路如下：
1. 我们用两个指针left,right分别指向数组的第一个元素和最后一个元素。按照题目的旋转的规则，第一个元素应该是大于最后一个元素的(假设没有重复的元素时)，但是如果不是旋转，第一个元素肯定小于最后一个元素。
2. 找到数组的中间元素。中间元素大于第一个元素，则中间元素是属于前面的递增子数组，此时最小元素位于中间元素的后面。我们可以让第一个指针left指向中间元素，移动之后，第一个指针仍然位于前面的递增数组中；当中间元素小于第一个元素，则中间元素是属于后面的递增子数组，此时最小元素位于中间元素的前面。我们可以让第二个指针right指向中间元素，移动之后，第二个指针仍然位于后面的递增数组中，这样就可以缩小寻找的范围。
3. 按照上述思路，第一个指针left总是指向前面递增的元素，第二个指针right总是指向后面递增的数组元素。为此，`最终第一个指针将指向前面数组的最后一个元素，第二个指针指向后面数组的第一个元素`。也就是说他们将指向两个相邻的元素，而第二个指针指向的刚好是最小的元素，这也是循环的结束条件。
4. 上面是在`没有重复元素的假设下进行的`，然而现实情况是有特殊情况的，比如：{1,0,1,1,1}和{1,1,1,0,1}都可以看成是递增排序数组{0,1,1,1,1}的旋转。在这种情况下，我们就没法利用上面提到的解法去解决，因为在这两个数组中第一个数字、最后一个数字、中间数字都是1。第一种情况下，中间数字位于后面的子数组，第二种情况下，中间数字位于前面的子数组。**因此当两个指针指向的数字和中间数字相同的时候，我们无法确定中间数字1是属于前面还是属于后面的子数组，因此也就无法移动指针来缩小查找的范围。为此，就需要通过线性查找的方法。**

```java
public int minNumberInRotateArray(int[] array){
    int size = array.length;
    if(size == 0){
        return 0;
    }
    int left = 0;
    int right = size - 1;
    int mid = 0;
    //array[left] >= array[right] 确保数据旋转
    while(array[left] >= array[right]){
        //分界点
        if(right - left == 1){
            mid = right;
            break;
        }
        mid = left + (right - left) / 2;
        //array[left], array[right], array[mid]三者相等的时候，无法确定中间元素是属于前面还是后面的递增子数组，只能顺序查找
        if (array[left] == array[right] && array[left] == array[mid]){
            return MinOrder(array,left,right);
        }

        //中间元素位于前面的递增子数组，此时最小的元素位于中间元素的后面
        if(array[mid] >= array[left]){
            left = mid;
        }
        else{
            //中间元素位于后面的递增子数组，此时最小元素位于中间元素的前面
            right = mid;
        }
    }
    return array[mid];
}

private int MinOrder(int[] array, int left, int right){
    int result = array[left];
    for(int i = left + 1; i < right; i++){
        if(array[i] < result){
            result = array[i];
        }
    }
    return result;
}
```

感觉上面的文字描述太过于复杂繁琐，为此，给出同样思路的另一种解释说明如下：

采用二分法解答这个问题，mid = low + (high - low)/2,需要考虑三种情况：
- array[mid] > array[high]:出现这种情况的array类似于{3,4,5,6,0,1,2}，此时最小数字一定在mid的右边，所以low = mid + 1;
- array[mid] == array[high]：出现这种情况array类似于{1,0,1,1,1}或者{1,1,1,0,1}，此时最小数字不好判断在mid的右边还是左边，这时只好一个一个尝试，所以high = high - 1;
- array[mid] < array[high]:出现这种情况的array类似于{2,2,3,4,5,6,6}，此时最小数字一定是在mid的左边，因为右边必然是递增的，所以high = mid。

**注意**：如果待查询的范围最后只剩两个数，那么mid 一定会指向下标靠前的数字。比如array = [4,6],array[low] = 4 ;array[mid] = 4 ; array[high] = 6 ; 如果high = mid - 1，就会产生错误， 因此high = mid,但是low = mid + 1就不会出错。

```java
 public int minNumberInRotateArray(int [] array) {
    int low = 0 ; int high = array.length - 1;
    while(low < high){
        if(array[low] < array[high]){
            return array[low];
        }
        int mid = low + (high - low) / 2;
        if(array[mid] > array[high]){
            low = mid + 1;
        }else if(array[mid] == array[high]){
            high = high - 1;
        }else{
            high = mid;
        }
    }
    return array[low];
}
```

### 7. 斐波那契数列

**题目描述**

大家都知道斐波那契数列，现在要求输入一个整数n,请你输出斐波那契数列的第n项(从0开始，第0项为0， n<=39>)。

**解题思路**：

> 思路1：常用的递归法。斐波那契数列的标准公式为：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n>=3，n∈N*），根据公式直接写出答案。

```java
public class Solution {
    public int Fibonacci(int n) {
        if(n<=1){
            return n;
        }
        return Fibonacci(n-1) + Fibonacci(n-2);
    }
}
```

还有一种尾递归的解决思路，如下所示：(但是实际上JVM并没有对尾递归进行优化)

```java
public class Solution {
    public int Fibonacci(int n) {
        return Fibonacci(n,0,1);
    }


    private static int Fibonacci(int n,int acc1,int acc2){
        if(n==0) return 0;
        if(n==1) return acc2;
        else     
           return Fibonacci(n - 1, acc2, acc1 + acc2);
    }
}
```

> 思路2：迭代法。很明显递归容易超时，那是递归在计算的时候，计算过很多次已经计算过的结果，可以保存下来。迭代的时候，只关注当前的数的前一个和前两个，每次用变量临时纪录起来，那么只需相加即可，而不是像递归那样重复计算。

```java
public class Solution {
    public int Fibonacci(int n) {
        if(n <= 1){
            return n;
        }
        int sum = 0;
        int two = 0;
        int one = 1;
        for(int i=2;i<=n;i++){
            sum = two + one;
            two = one;
            one = sum;
        }
        return sum;
    }
}
```
我们在观察上面的代码其实可以发现，sum只在每次计算第n项的时候用一下，其实还可以用sum来存储第n-1项，例如当计算完 f(5) 时 sum 存储的是 f(5) 的值，当需要计算 f(6) 时，f(6) = f(5) - f(4)，sum 存储的 f(5)，f(4) 存储在 one 中，由 f(5)-f(3) 得到。

```java
public class Solution {
    public int Fibonacci(int n) {
        if(n <= 1){
            return n;
        }
        int sum = 1;
        int one = 0;
        for(int i=2;i<=n;i++){
            sum = sum + one;
            one = sum - one;
        }
        return sum;
    }

    //或者更简洁的写法
    public int FibonacciOptimize2(int n)
    {
        int f = 0, g = 1;
        while(n -- > 0)
        {
            g += f;
            f = g - f;
        }
        return f;
    }
}
```

> 思路3：矩阵链乘法。具体思路查看下面文章。

[【剑指Offer】斐波那契数列](https://blog.csdn.net/FightLei/article/details/89391112)

```java
// 简单实现了2*2矩阵的乘法
public int[,] matrixMul(int[,] m, int[,] n)
{
    int[,] ret = {
        { m[0,0] * n[0,0] + m[0,1] * n[1,0],  m[0,0] * n[0,1] + m[0,1] * n[1,1]} ,
        { m[1,0] * n[0,0] + m[1,1] * n[1,0],  m[1,0] * n[0,1] + m[1,1] * n[1,1]}
    };
    return ret;
}
// 矩阵的快速幂
public int[,] matrixPow(int[,] m, int n)
{
	// 单位矩阵，作用相当于整数乘法中的1
    int[,] ret = { { 1, 0 }, { 0, 1 } };
    while(n > 0)
    {
        if ((n & 1) > 0)
        {
            ret = matrixMul(m, ret);
        }
        m = matrixMul(m, m);
        n >>= 1;
    }
    return ret;
}

public int FibonacciOptimize4(int n)
{
    if (n == 0)
    {
        return 0;
    }
    int[,] matrix = { { 1, 1 }, { 1, 0 } };
    // 这里的F1和F0矩阵多加了一列0,0，不会影响最终结果，是因为matrixMul只实现了2*2矩阵的乘法
    int[,] unit = { { 1, 0 }, { 0, 0 } };
    // 调用前面代码的矩阵乘法和矩阵快速幂
    int[,] ret = matrixMul(matrixPow(matrix, n - 1), unit);
    return ret[0, 0];
}

```

### 8. 跳台阶

